---
description: 编写：倪士平
---

# 1.3 从汇编的视角理解程序运行

在本节中，我们进一步深入理解程序的运行过程，如题所示，我们将从汇编代码运行的层面去看一看程序在CPU中的执行过程。笔者能力有限，篇幅也有限，如有困惑还请参照推荐书籍中的相关内容。

## 典型的计算机系统硬件组成

在介绍程序运行过程之前，我们需要了解一下一个典型的计算机系统的硬件组成是怎样的。

如图1-4所示，一个典型的计算机系统通常包括四个部分：总线、I/O设备、主存、处理器

1.总线

总线是计算机系统传输信息的通道，连接各个部件，通常被设计成传输定长的字节块。

2.I/O设备

I/O就是输入/输出（input/output），I/O设备时计算机系统与外部世界的交互通道，图1-4中包含的I/O设备有鼠标、键盘、磁盘、显示器。每个I/O设备通过控制器或适配器（两者的区别在于封装方式）与I/O总线连接。

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption><p>硬件组成</p></figcaption></figure>

3.主存

主存是一个临时存储设备，在处理器**执行程序时，用来存放程序和程序处理的数据**。从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。

4.处理器

中央处理单元(CPU)，简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或寄存器)，称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。从系统通电开始，直到系统断电，处理器不断地执行程序计数器指向的指令， 再更新程序计数器，使其指向下一条指令。

处理器看上去是按照一个非常简单的指令执行模型来操作的，在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。**处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令， 而这条指令并不一定和在内存中刚刚执行的指令相邻。**

## CPU中寄存器

IA-64架构下的CPU包括四类寄存器：通用寄存器，段寄存器，程序状态与控制寄存器，指令指针寄存器，这里我们仅介绍其中的一类——通用寄存器。

通用寄存器共十六个,包含rax、rbx、rcx、rdx、rbp、rsi、rdi、rsp、r8-r15，每个寄存器都可以存储64位数据。除了r8-r15均是由IA-32中的32位寄存器拓展而来的，因此支持操作这些寄存器的低32位，使用时用e代替e即可。

汇编指令可以直接操作这些寄存器，我们看一下上一节中经过简化的`helloworld`程序的汇编

```asmatmel
// assembley
.LC0:	"Hello World!"

sub    $8, %rsp
lea    .LC0(%rip), %rdi
mov    $0, %eax
call    printf@PLT
mov    $0, %eax
add    $8, %rsp
mov    $0, %eax
add    $8, %rsp
ret
```

`$+数字`表示是一个常数，`%+寄存器名`表示某个寄存器。为简化理解，初始状态下我们假设rsp指向了某一个值，它代表了一个数组开始的位置，该数组的索引为非正数。



上面的代码中，首先是我们给了字符串“Hello World!”一个标签，叫做“LC0”，方便我们在代码中引用它。

汇编代码的格式为`code op0 op1`，表示op1执行code参数为op0，如sub    $8, %rsp表示寄存器rsp减8
